import sys

hashMap = [
   [0xf, 0x7, 0x6, 0x4, 0x5, 0x1, 0x0, 0x2, 0x3, 0xb, 0xa, 0x8, 0x9, 0xd, 0xc, 0xe],
   [0x2, 0x3, 0xb, 0xa, 0x8, 0x9, 0xd, 0xc, 0xe, 0xf, 0x7, 0x6, 0x4, 0x5, 0x1, 0x0],
   [0x6, 0x4, 0x5, 0x1, 0x0, 0x2, 0x3, 0xb, 0xa, 0x8, 0x9, 0xd, 0xc, 0xe, 0xf, 0x7],
   [0x8, 0x9, 0xd, 0xc, 0xe, 0xf, 0x7, 0x6, 0x4, 0x5, 0x1, 0x0, 0x2, 0x3, 0xb, 0xa],
   [0x5, 0x1, 0x0, 0x2, 0x3, 0xb, 0xa, 0x8, 0x9, 0xd, 0xc, 0xe, 0xf, 0x7, 0x6, 0x4],
   [0xb, 0xa, 0x8, 0x9, 0xd, 0xc, 0xe, 0xf, 0x7, 0x6, 0x4, 0x5, 0x1, 0x0, 0x2, 0x3],
   [0x0, 0x2, 0x3, 0xb, 0xa, 0x8, 0x9, 0xd, 0xc, 0xe, 0xf, 0x7, 0x6, 0x4, 0x5, 0x1],
   [0x7, 0x6, 0x4, 0x5, 0x1, 0x0, 0x2, 0x3, 0xb, 0xa, 0x8, 0x9, 0xd, 0xc, 0xe, 0xf],
   [0x3, 0xb, 0xa, 0x8, 0x9, 0xd, 0xc, 0xe, 0xf, 0x7, 0x6, 0x4, 0x5, 0x1, 0x0, 0x2],
   [0x1, 0x0, 0x2, 0x3, 0xb, 0xa, 0x8, 0x9, 0xd, 0xc, 0xe, 0xf, 0x7, 0x6, 0x4, 0x5],
   [0xa, 0x8, 0x9, 0xd, 0xc, 0xe, 0xf, 0x7, 0x6, 0x4, 0x5, 0x1, 0x0, 0x2, 0x3, 0xb],
   [0x4, 0x5, 0x1, 0x0, 0x2, 0x3, 0xb, 0xa, 0x8, 0x9, 0xd, 0xc, 0xe, 0xf, 0x7, 0x6],
   [0x9, 0xd, 0xc, 0xe, 0xf, 0x7, 0x6, 0x4, 0x5, 0x1, 0x0, 0x2, 0x3, 0xb, 0xa, 0x8],
   [0xd, 0xc, 0xe, 0xf, 0x7, 0x6, 0x4, 0x5, 0x1, 0x0, 0x2, 0x3, 0xb, 0xa, 0x8, 0x9],
   [0xc, 0xe, 0xf, 0x7, 0x6, 0x4, 0x5, 0x1, 0x0, 0x2, 0x3, 0xb, 0xa, 0x8, 0x9, 0xd],
   [0xe, 0xf, 0x7, 0x6, 0x4, 0x5, 0x1, 0x0, 0x2, 0x3, 0xb, 0xa, 0x8, 0x9, 0xd, 0xc]
];

upperMask = 0xF0
lowerMask = 0x0F

def findCandidateLetters(matrix):
    for letter in matrix[0]:
        distances = []
        for i in range(1, len(matrix)):
            if letter in matrix[i]:
                distances.append(i)
        print letter, distances
        #in order for any key to be valid, the remaining letters would have to
        #occur at indices in between these distances

def breadthFirstSearchSequences(matrix):

    candidateKeys = []
    queue = matrix[0]
    i = 0
    while len(queue) > 0:

        testSequence = queue.pop(0)

        if assertSequenceRepeatsThroughMatrix(testSequence, matrix):
            candidateKeys.append(testSequence)

        for letter in matrix[i]:
            queue.append(testSequence + letter)

        i += 1

    return candidateKeys

def assertSequenceRepeatsThroughMatrix(sequence, matrix):
    j = 0
    i = 0
    while i < len(matrix):
        if j >= len(sequence) - 1:
            j = 0
        if sequence[j] not in matrix[i]:
            return False
        i += 1
        j += 1
    return True

def encrypt(character, key_character):
    binary_char = ord(character)
    binary_key = ord(key_character)
    ph = (binary_char & 0xF0) >> 4
    pl = binary_char & 0x0F
    kh = (binary_key & 0xF0) >> 4
    kl = binary_key & 0x0F
    mapped = hashMap[ph][kl] << 4 | hashMap[pl][kh]
    return mapped

def findIndices2dArray(arr, item):
    matching = []
    for p in range(len(arr)):
        for k in range(len(arr[0])):
            if (arr[p][k] == item):
                matching.append((p, k))
    return matching

def isPrintableAscii(hex):
    return hex >= 32 and hex < 127

def isValidAscii(hex):
    return hex >= 0 and hex <= 127

def main():
    for line in sys.stdin:
        normal = []
        possibleKeyMatrix = []
        possibleCiphertextMatrix = []
        for byte in line:
            ch = (ord(byte) & upperMask) >> 4
            cl = ord(byte) & lowerMask
            ch_indices = findIndices2dArray(hashMap, ch)
            cl_indices = findIndices2dArray(hashMap, cl)
            possibleKeyCharacterVector = []
            possibleCiphertextVector = []
            for pl, kh in cl_indices:
                for ph, kl in ch_indices:
                    if isPrintableAscii(ph << 4 | pl) and isValidAscii(kh << 4 | kl):
                        possibleCiphertextVector.append(chr(ph << 4 | pl))
                        possibleKeyCharacterVector.append(chr(kh << 4 | kl))

            possibleKeyMatrix.append(possibleKeyCharacterVector)
            possibleCiphertextMatrix.append(possibleCiphertextVector)

    findCandidateLetters(possibleKeyMatrix)

main()
